# -*- coding: utf-8 -*-
"""TSO.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/13VdWar-yqlPQcdMGSS4Aociq388gDVYP
"""

import numpy as np
from numpy.random import rand
from numpy import inf
import math

def fun(X):
    output = sum(np.square(X))
    return output

def TSO(SearchAgents_no,lb,ub,dim):
    l=0
    L=100
    best_voltage=np.zeros([1,dim])                                                   # initialize best voltage vector
    Convergence_curve = np.zeros([1,L])

    best_score=inf   
    voltages=np.multiply(random.rand(SearchAgents_no,dim),(ub-lb))+lb                      #Initialize the voltages of search agents
    Convergence_curve[0]=best_score
# Main loop
    while l<L:
      for i in range(np.size(voltages,0)):
        
        #Return back the search agents that go beyond the boundaries of the search space
        Flag4ub=voltages[i,:]>ub
        Flag4lb=voltages[i,:]<lb
        voltages[i,:]=np.multiply(voltages[i,:],(~(Flag4ub+Flag4lb)))+np.multiply(ub,Flag4ub)+np.multiply(lb,Flag4lb)
               
        fitness=fun(voltages[i,:])                # Calculate objective function for each search agent
        
        #Update the best
        if fitness<best_score:
            best_score=fitness 
            best_voltage=voltages[i,:]
        
        
    
    
      t=2-l*(2/L)
      K=1                        #K is a real can be 0, 1, 2,....

      Convergence_curve[0,l] = best_score
      print("Iteration:", l + 1)
      print("Best (TSO):", Convergence_curve[0,l])
      l += 1
    #Update the voltage of search agents 
      for i in range(np.size(voltages,0)):
        r1=rand()
        r2=rand() 
        r3 = rand()
        T=2*t*r1-t  
        C1=K*r2*t+1            
               
        for j in range(np.size(voltages,1)):
           
            if r3<0.5:
           
                voltages[i,j]=best_voltage[j]+np.exp(-T)*(voltages[i,j]-C1*best_voltage[j])
                
            elif r3>=0.5:
            
              voltages[i,j]=best_voltage[j]+np.exp(-T)*(np.cos(T*2*math.pi)+np.sin(T*2*math.pi))*abs(voltages[i,j]-C1*best_voltage[j]);
            
                        
        
    
    return voltages,Convergence_curve

import numpy as np
import pandas as pd
from numpy import random
import matplotlib.pyplot as plt


# parameter
N    = 5    # number of particles
T    = 100  # maximum number of iterations
dim = 20                    # The dimension.
fl=-100                     # The lower bound of the search interval.
ul=100                      # The upper bound of the search interval.
lb = fl*np.ones([1,dim])
ub = ul*np.ones([1,dim])
# perform feature selection
voltages,Convergence_curve = TSO(N, lb,ub,dim)

curve   = Convergence_curve.reshape(np.size(Convergence_curve,1))
x       = np.arange(0, T, 1.0) + 1.0

fig, ax = plt.subplots()
ax.plot(x,curve, 'o-')
ax.set_xlabel('Number of Iterations')
ax.set_ylabel('Fitness')
ax.set_title('TSO')
ax.grid()
plt.show()